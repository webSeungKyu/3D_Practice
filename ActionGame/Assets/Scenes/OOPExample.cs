using System.Collections;
using System.Collections.Generic;
using UnityEngine;
#region OOP 설명
/*
 객체 지향 프로그래밍(OOP)
기존의 방식 : 프로그램은 명령어들의 집합
객체 지향식 설계 : 프로그램은 객체들의 모임

클래스 : 객체 지향 프로그램의 기본 구성요소이자 사용자 정의 데이터 타입
>> 변수와 함수를 같이 저장할 수 있는 자료구조

객체 : 클래스가 실제로 메모리 상에 할당된 인스턴트
필드 : 클래스 내부에 설계된 변수, 객체의 속성을 표현
메소드 : 클래스 내부에 설계된 함수, 객체의 기능, 동작을 표현합니다

객체 진향 설계의 목적(특징)

1. 캡슐화 : 클래스 내부의 서로 연관되어있는 속성과 기능을 하나의 캡슐처럼 만들어
데이터가 외부로 노출되는 것을 방지하는 설계법

2. 상속 : class 자식클래스명 : 부모클래스명의 형태로 설계
부모 클래스가 가진 모든 변수와 함수를 상속받고 그 기능을 사용할 수 있습니다
상황에 맞게 재정의하여 새로운 기능으로 만들어주는 것도 가능합니다

3. 다향성 : 같은 이름의 변수, 함수여도 상황에 따라 다른 의미로 사용될 수 있음. (조건에 따라 다르게 수행)

 */
#endregion
#region 자료구조 설명
/*
 자료구조 (Data Structure)
효율적인 접근과 수정을 가능하게하는 자료의
조직, 관리, 저장, 데이터 값의 모임, 데이터의 관계 등을 종합해서 일컫는 말

자료구조 유형별 정리
T : 타입, K : 키, V : 값
[명칭]                  [용도]
LinkedList<T>           데이터의 등록과 삭제가 빈번하게 발생하는 경우 해당 자료구조를 사용합니다          
List<T>                 데이터가 저장된 순서(인덱스)를 빠르게 탐색할 수 있습니다      
Stack<T>                데이터를 후입 선출(LIFO)의 방식으로 사용할 경우 해당 자료구조를 사용합니다    
Queue<T>                데이터를 선입 선출(LIFO)의 방식으로 사용할 경우 해당 자료구조를 사용합니다    
Dictionary<K,V>         특정 키를 통해 특정 값을 조회하는 경우 해당 자료구조를 사용합니다
HashSet<T>              중복되지 않은 데이터를 저장하고자 할 떄 사용합니다 ( 수학적으로 집합의 개념 표현 시에도 )
T[]                     리스트처럼 데이터가 인덱스에 의해 관리되며, 메모리 상에 연속적으로 저장되는 자료구조
                        - 고정된 크기를 가지고 있고, 추가 소모되는 메모리 없이 딱 크기에 맞게 제공됩니다
                        - 유니티 에디터 상에선 배열과 리스트는 동일하게 취급되나 스크립트를 작업 시에는
                        - 배열과 리스트의 사용법이 다르기 때문에 이에 유의합니다

자료구조별 알고리즘 단계의 수 파악
데이터 원소 N개에 대한 알고리즘의 단계 수를 파악하면 해당 자료구조가 빠른지 느린지를 판단 가능
위에 적힌 자료구조 순서대로 시간 복잡도 표현

영어 O
O(1) : 데이터의 증가, 감소에 영향을 받지 않고 단계 수가 일정하게 유지됩니다
O(n) : 그래프로 보면 완벽하게 대각선의 형태로 표현, 데이터 추가 당 알고리즘이 1단계씩 증가
 - 데이터가 많아질수록 작업의 효율이 나빠집니다
O(log n) : 아주 조금씩 증가하는 형태의 곡선으로 데이터가 약 두 배 증가할 때마다 1단계 정도 늘어남

효율 분석
O(1) > O(log n) > O(n)
O(1)은 O(log n)과 비교했을 때 비등하다 데이터의 개수가 약 100개 이상을 넘을 경우 O(1)이 효율적이게 됩니다
 - 로그(log)는 이렇게 이해해보자
2를 몇 번 곱해야 N이 나오는가? log₂N
1이 될 때까지 N을 2로 몇 번 곱해야하는가? log₂N

[명칭]          [추가]        [검색]        [삭제]        [인덱스로 인한 접근]
LinkedList<T>    O(1)           O(n)        O(n)           O(n)
List<T>          O(1)           O(n)        O(n)           O(1)
Stack<T> 
Queue<T>
HashSet<T>   
Dictionary<K,V>
T[]  
 */
#endregion
public class OOPExample : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
